### Школа Java Developer
#### Домашнее задание №11 

1. Как получить ссылку на текущий поток ?
```java
	Thread.currentThread()  
```

2. Зачем нужно ключевое слово synchronized ? На что его можно вещать(поле, метод,
класс, конструктор..)?
  Synchronized обеспечивает синхронизацию между потоками критической области кода. Можно вешать на методы и оборачивать в блок кода

3. Захват какого монитора происходит при входе в synchronized метод/статик метод/блок ?
  Каждый объект неявно имеет intrinsic lock
  synchronized метод - intrinsic lock this объекта
  synchronized статик метод - intrinsic lock у Class<ThisClass> 
  synchronized блок - intrinsic lock объекта который мы выбрали как монитор в этом блоке

4. Зачем нужно ключевое слово volatile ? На что его можно вещать(поле, метод, класс,
конструктор..)?
  Для соблюдения консистентности состояний между потоками, нарушение которой может произойти из за кеширования. Вешается только на переменные

5. Что делает метод Object#wait, Object#notify, Object#notifyAll
  Object#wait() - поток блокируется до вызова другим потоком Object#notify, Object#notifyAll на том же объекте
  Object#notify - разблокирует произвольный поток ранее вызвавший wait()
  Object#notify - разблокирует все потоки ранее вызвавшие wait()

6. Что за исключение IllegalMonitorStateException?
  Методы из прошлого вопроса можно вызывать только с захваченным объектом на котором будет вызываться метод. Иначе вылетит это исключение

7. Что делает метод Thread#join ?
  Вызвавший метод поток блокируется до завершения потока с которым связан объект Thread на котором этот метод вызвали

8. Что делает метод Thread#interrupt ?
  Ставит флаг interrupted в true на объект потока. 

### Задание: 
Реализовать ThreadPool
```java
public interface ThreadPool {
  void start(); // запускает потоки. Потоки бездействуют, до тех пор пока не появится новое задание в очереди (см. execute)
  void execute(Runnable runnable); // складывает это задание в очередь. Освободившийся поток должен выполнить это задание. Каждое задание должны быть выполнено ровно 1 раз
}
```
Сделать 2 реализации ThreadPool
1) FixedThreadPool - Количество потоков задается в конструкторе и не меняется.
2) ScalableThreadPool в конструкторе задается минимальное и максимальное(int min, int max) число потоков, количество запущенных потоков может быть увеличено от минимального к максимальному, если при добавлении нового задания в очередь нет свободного потока для исполнения этого задания. При отсутствии задания в очереди, количество потоков опять должно быть уменьшено до значения min

### ScalableThreadPool 
Метод execute - добавляет задачу в очередь задач и создает нового Worker если колличество воркеров < maximumPoolSize, выбрасывает IllegalStateException если нет места для новой задачи в очереди

Класс Worker - класс, представляющий собой поток, который выполняет задачи из очереди. Метод run() в цикле вызывает Worker::nextTask() извлекая задачу из очереди и выполняет ее если она возвращается, задача может и не вернуться это означает что потоков больше чем corePoolSize и инстанс Worker которому не выдали задачу выходит из цикла и удаляется из пула 

Worker::nextTask() - сначала выполняет проверку на количество потоков, если потоков больше чем corePoolSize - removeCandidatesAmount воркер увеличит счетчик removeCandidatesAmount и будет ждать задачу keepAliveTime времени по истечению которого уменьшит счетчик в любом случае и будет удален(см. класс Worker) если задача не пришла или останется в живых если задача пришла. Если же количество потоков изначально не превышало corePoolSize поток будет заблокирован без ограничений по времени, ожидая новую задачу, так же не будет увеличивать счетчик кандидатов на удаление.

### FixedThreadPool
Тот же ScalableThreadPool но у него corePoolSize = maximumPoolSize
